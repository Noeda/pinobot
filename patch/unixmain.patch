--- /home/shannon/gitjutut/nethack-3.4.3/sys/unix/unixmain.c	2003-12-08 01:39:13.000000000 +0200
+++ unixmain.c	2013-05-13 18:18:59.100622410 +0300
@@ -44,11 +44,15 @@
 static boolean wiz_error_flag = FALSE;
 #endif
 
+static int extract_data(int argc, char* argv[]);
+
 int
 main(argc,argv)
 int argc;
 char *argv[];
 {
+        return extract_data(argc, argv);
+
 	register int fd;
 #ifdef CHDIR
 	register char *dir;
@@ -538,4 +542,439 @@
 	return;
 }
 
+
+
+
+
+/*** EXTRACTOR STUFF ***/
+
+#include "date.h"
+static void extract_monsterdata_to_haskell(
+        FILE* f
+      , const char* variant
+      , const char* command_prefix );
+static const char* detect_variant( const char** command_prefix );
+
+static int extract_data(int argc, char* argv[])
+{
+    FILE* f;
+    char name[300];
+    const char* command_prefix, *variant_str;
+
+    if (argc <= 1)
+    {
+        printf("Usage:\n");
+        printf("%s [language]\n\n", argv[0]);
+        printf("Where language is one of: \n");
+        printf("  haskell\n\n");
+        return 0;
+    }
+
+    variant_str = detect_variant( &command_prefix );
+    sprintf( name, "%s.hs", variant_str );
+    if (argc >= 2 && !strcmp(argv[1], "haskell"))
+    {
+        fprintf( stderr, "Writing to '%s'...\n", variant_str );
+        f = fopen(name, "wb");
+        if (!f)
+        {
+            perror("fopen");
+            return -1;
+        }
+        extract_monsterdata_to_haskell(f, variant_str, command_prefix );
+        fclose(f);
+        fprintf( stderr, "Done.\n" );
+    }
+    else
+    {
+        fprintf(stderr,
+               "I don't what %s is. Try running %s without "
+               "parameters to see the valid languages.\n",
+               argv[1], argv[0]);
+        return -1;
+    }
+
+    return 0;
+}
+
+static const char* detect_variant( const char** command_prefix )
+{
+    const char* vid = VERSION_ID;
+    if ( strstri( vid, "UnNetHackPlus" ) ) {
+        (*command_prefix) = "u+";
+        return "UnNetHackPlus";
+    }
+    if ( strstri( vid, "UnNetHack" ) ) {
+        (*command_prefix) = "u";
+        return "UnNetHack";
+    }
+    if ( strstri( vid, "SporkHack" ) ) {
+        (*command_prefix) = "s";
+        return "SporkHack";
+    }
+    if ( strstri( vid, "NetHack Version 3.4.3" ) ) {
+        (*command_prefix) = "v";
+        return "Vanilla";
+    }
+
+    fprintf( stderr
+           , "I don't know what variant this is. "
+           "Replace module, data type name and command prefix manually. "
+           "Search for 'ReplaceThisName' in the resulting source file.\n" );
+
+    (*command_prefix) = "ReplaceThisName";
+
+    return "ReplaceThisName";
+}
+
+static void extract_monsterdata_to_haskell(
+        FILE* f
+      , const char* variant
+      , const char* command_prefix )
+{
+    int i1, i2;
+    struct permonst* pm;
+    struct monst dummymonst;
+
+    memset(&dummymonst, 0, sizeof(dummymonst));
+
+    /* We want to import everything in this module. */
+    fprintf(f, "-- Automatically generated --\n");
+    fprintf(f, "{-# LANGUAGE OverloadedStrings #-}\n");
+    fprintf(f, "module NetHack.Imported.%s ( variant ) where\n\n"
+           , variant );
+    fprintf(f, "import qualified Data.Text as T\n");
+    fprintf(f, "import qualified NetHack.Data.Dice as D\n");
+    fprintf(f, "import qualified NetHack.Data.Variant as V\n");
+    fprintf(f, "import NetHack.Data.Monster\n\n");
+
+    fprintf(f, "variant :: V.Variant\n");
+    fprintf(f, "variant = V.variant monster allMonsterNames \"%s\"\n\n"
+             , command_prefix );
+
+    fprintf(f, "monster :: T.Text -> Maybe Monster\n");
+    fprintf(f, "monster name\n");
+    for (i1 = 0; mons[i1].mname[0]; ++i1)
+    {
+        pm = &mons[i1];
+        dummymonst.data = pm;
+
+        fprintf(f, "  | name == \"%s\" = ", pm->mname);
+        fprintf(f, "Just Monster { ");
+        fprintf(f, "moName = \"%s\", ", pm->mname);
+        if (def_monsyms[pm->mlet] != '\'')
+            fprintf(f, "moSymbol = '%c', ", def_monsyms[pm->mlet]);
+        else
+            fprintf(f, "moSymbol = '\\'', ");
+        fprintf(f, "moBaseLevel = %d, ", pm->mlevel);
+        fprintf(f, "moSpeed = %d, ", pm->mmove);
+        fprintf(f, "moAC = %d, ", pm->ac);
+        fprintf(f, "moMR = %d, ", pm->mr);
+        fprintf(f, "moAlign = %d, ", pm->maligntyp);
+        fprintf(f, "moGenerationPlaces = tail [Gehennom");
+        if (pm->geno & G_UNIQ)
+            fprintf(f, ", Unique");
+        else if (pm->geno & G_NOGEN)
+            fprintf(f, "");
+        else
+        {
+#ifdef G_SHEOLONLY
+            if (pm->geno & (G_SHEOLONLY & ~G_SHEOL))
+                fprintf(f, ", Sheol");
+            else
+            {
+                if (pm->geno & G_SHEOL) fprintf(f, ", Sheol");
+#endif
+                if (!(pm->geno & G_NOHELL)) fprintf(f, ", Gehennom");
+                if (!(pm->geno & G_HELL)) fprintf(f, ", Dungeons");
+#ifdef G_SHEOLONLY
+            }
+#endif
+        }
+        fprintf(f, "], ");
+        fprintf(f, "moLeavesCorpse = %s, ",
+                (pm->geno & G_NOCORPSE) ? "False" : "True");
+        fprintf(f, "moNotGeneratedNormally = %s, ",
+                (pm->geno & G_NOGEN) ? "True" : "False");
+        fprintf(f, "moAppearsInSmallGroups = %s, ",
+                (pm->geno & G_SGROUP) ? "True" : "False");
+        fprintf(f, "moAppearsInLargeGroups = %s, ",
+                (pm->geno & G_LGROUP) ? "True" : "False");
+        fprintf(f, "moGenocidable = %s, ",
+                (pm->geno & G_GENO) ? "True" : "False");
+        fprintf(f, "moAttacks = [");
+        for (i2 = 0; i2 < NATTK && (pm->mattk[i2].aatyp ||
+                                    pm->mattk[i2].adtyp ||
+                                    pm->mattk[i2].damn ||
+                                    pm->mattk[i2].damd); ++i2)
+        {
+            if (i2 > 0)
+                fprintf(f, ", ");
+
+            fprintf(f, "Attack ");
+#define AT(a, b) else if (pm->mattk[i2].aatyp == a) fprintf(f, "%s ", b);
+            if (1 + 1 == 3) { } /* I hope we won't run this code 
+                                   in a universe where 1+1 is 3. */
+            AT(AT_NONE, "AtNone")
+            AT(AT_CLAW, "AtClaw")
+            AT(AT_BITE, "AtBite")
+            AT(AT_KICK, "AtKick")
+            AT(AT_BUTT, "AtButt")
+            AT(AT_TUCH, "AtTouch")
+            AT(AT_STNG, "AtSting")
+            AT(AT_HUGS, "AtHug")
+            AT(AT_SPIT, "AtSpit")
+            AT(AT_ENGL, "AtEngulf")
+            AT(AT_BREA, "AtBreath")
+            AT(AT_EXPL, "AtExplode")
+            AT(AT_BOOM, "AtSuicideExplode")
+            AT(AT_GAZE, "AtGaze")
+            AT(AT_TENT, "AtTentacle")
+            AT(AT_WEAP, "AtWeapon")
+            AT(AT_MAGC, "AtCast")
+#ifdef AT_SCRE
+            AT(AT_SCRE, "AtScre")
+#endif
+            else { fprintf(stderr,
+                    "I don't know what attack type %d is.\n", pm->mattk[i2].aatyp);
+                   abort(); }
+#undef AT
+#define AT(a, b) else if (pm->mattk[i2].adtyp == a) fprintf(f, "%s ", b);
+            if (1 == 2) { }
+            AT(AD_PHYS, "AdPhys")
+            AT(AD_MAGM, "AdMagicMissile")
+            AT(AD_FIRE, "AdFire")
+            AT(AD_COLD, "AdCold")
+            AT(AD_SLEE, "AdSleep")
+            AT(AD_DISN, "AdDisintegrate")
+            AT(AD_ELEC, "AdElectricity")
+            AT(AD_DRST, "AdStrDrain")
+            AT(AD_ACID, "AdAcid")
+            AT(AD_BLND, "AdBlind")
+            AT(AD_STUN, "AdStun")
+            AT(AD_SLOW, "AdSlow")
+            AT(AD_PLYS, "AdParalyse")
+            AT(AD_DRLI, "AdLevelDrain")
+            AT(AD_DREN, "AdMagicDrain")
+            AT(AD_LEGS, "AdLegs")
+            AT(AD_STON, "AdStone")
+            AT(AD_STCK, "AdSticking")
+            AT(AD_SGLD, "AdGoldSteal")
+            AT(AD_SITM, "AdItemSteal")
+            AT(AD_SEDU, "AdSeduce")
+            AT(AD_TLPT, "AdTeleport")
+            AT(AD_RUST, "AdRust")
+            AT(AD_CONF, "AdConfuse")
+            AT(AD_DGST, "AdDigest")
+            AT(AD_HEAL, "AdHeal")
+            AT(AD_WRAP, "AdWrap")
+            AT(AD_WERE, "AdWere")
+            AT(AD_DRDX, "AdDexDrain")
+            AT(AD_DRCO, "AdConDrain")
+            AT(AD_DRIN, "AdIntDrain")
+            AT(AD_DISE, "AdDisease")
+            AT(AD_DCAY, "AdRot")
+            AT(AD_SSEX, "AdSex")
+            AT(AD_HALU, "AdHallucination")
+            AT(AD_DETH, "AdDeath")
+            AT(AD_PEST, "AdPestilence")
+            AT(AD_FAMN, "AdFamine")
+            AT(AD_SLIM, "AdSlime")
+            AT(AD_ENCH, "AdDisenchant")
+            AT(AD_CORR, "AdCorrode")
+            AT(AD_CLRC, "AdClerical")
+            AT(AD_SPEL, "AdSpell")
+            AT(AD_RBRE, "AdRandomBreath")
+            AT(AD_SAMU, "AdAmuletSteal")
+            AT(AD_CURS, "AdCurse")
+#ifdef AD_BHED
+            AT(AD_BHED, "AdBehead")
+#endif
+#ifdef AD_CNCL
+            AT(AD_CNCL, "AdCancellation")
+#endif
+#ifdef AD_LVLT
+            AT(AD_LVLT, "AdLevelTeleport")
+            AT(AD_BLNK, "AdBlink")
+#endif
+#ifdef G_SHEOL
+            AT(AD_FREZ, "AdFreeze")
+            AT(AD_PUNI, "AdPunisher")
+#endif
+#ifdef AD_HEAD
+            AT(AD_HEAD, "AdDecapitate")
+#endif
+            else { fprintf(stderr,
+                    "I don't know what attack damage type %d is.\n",
+                    pm->mattk[i2].adtyp); abort(); }
+#undef AT
+            fprintf(f, "(D.Dice %d %d)", pm->mattk[i2].damn, pm->mattk[i2].damd);
+        }
+        fprintf(f, "], ");
+        fprintf(f, "moWeight = %d, ", pm->cwt);
+        fprintf(f, "moNutrition = %d, ", pm->cnutrit);
+        fprintf(f, "moSize = ");
+        if (pm->msize == MZ_TINY) fprintf(f, "Tiny, ");
+        else if (pm->msize == MZ_SMALL) fprintf(f, "Small, ");
+        else if (pm->msize == MZ_MEDIUM) fprintf(f, "Medium, ");
+        else if (pm->msize == MZ_LARGE) fprintf(f, "Large, ");
+        else if (pm->msize == MZ_HUGE) fprintf(f, "Huge, ");
+        else if (pm->msize == MZ_GIGANTIC) fprintf(f, "Gigantic, ");
+        else { fprintf(stderr,
+                "I don't know what size %d means.\n", pm->msize); abort(); }
+
+        /* 'tail' for simpler generation code (don't have to check if we have
+         * to put in a comma). */
+        fprintf(f, "moResistances = (tail [ReFire");
+        if (pm->mresists & MR_FIRE) fprintf(f, ", ReFire");
+        if (pm->mresists & MR_COLD) fprintf(f, ", ReCold");
+        if (pm->mresists & MR_SLEEP) fprintf(f, ", ReSleep");
+        if (pm->mresists & MR_DISINT) fprintf(f, ", ReDisintegrate");
+        if (pm->mresists & MR_ELEC) fprintf(f, ", ReElectricity");
+        if (pm->mresists & MR_POISON) fprintf(f, ", RePoison");
+        if (pm->mresists & MR_ACID) fprintf(f, ", ReAcid");
+        if (pm->mresists & MR_STONE) fprintf(f, ", RePetrification");
+        if (resists_magm(&dummymonst)) fprintf(f, ", ReMagic");
+        if (resists_drli(&dummymonst)) fprintf(f, ", ReDrain");
+        fprintf(f, "]), ");
+        fprintf(f, "moConferred = (tail [ReFire");
+        if (pm->mconveys & MR_FIRE) fprintf(f, ", ReFire");
+        if (pm->mconveys & MR_COLD) fprintf(f, ", ReCold");
+        if (pm->mconveys & MR_SLEEP) fprintf(f, ", ReSleep");
+        if (pm->mconveys & MR_DISINT) fprintf(f, ", ReDisintegrate");
+        if (pm->mconveys & MR_ELEC) fprintf(f, ", ReElectricity");
+        if (pm->mconveys & MR_POISON) fprintf(f, ", RePoison");
+        if (pm->mconveys & MR_ACID) fprintf(f, ", ReAcid");
+        /* You can't actually get petrification resistance. */
+        // if (pm->mconveys & MR_STONE) fprintf(f, ", RePetrification");
+        fprintf(f, "]), ");
+
+        fprintf(f, "moFlags = (tail [FlFly");
+#define AT(a, b) if (pm->mflags1 & a) fprintf(f, ", %s", b);
+        AT(M1_FLY, "FlFly");
+        AT(M1_SWIM, "FlSwim");
+        AT(M1_AMORPHOUS, "FlAmorphous");
+        AT(M1_WALLWALK, "FlWallwalk");
+        AT(M1_CLING, "FlCling");
+        AT(M1_TUNNEL, "FlTunnel");
+        AT(M1_NEEDPICK, "FlNeedPick");
+        AT(M1_CONCEAL, "FlConceal");
+        AT(M1_HIDE, "FlHide");
+        AT(M1_AMPHIBIOUS, "FlAmphibious");
+        AT(M1_BREATHLESS, "FlBreathless");
+        AT(M1_NOTAKE, "FlNoTake");
+        AT(M1_NOEYES, "FlNoEyes");
+        AT(M1_NOHANDS, "FlNoHands");
+        AT(M1_NOLIMBS, "FlNoLimbs");
+        AT(M1_NOHEAD, "FlNoHead");
+        AT(M1_MINDLESS, "FlMindless");
+        AT(M1_HUMANOID, "FlHumanoid");
+        AT(M1_ANIMAL, "FlAnimal");
+        AT(M1_SLITHY, "FlSlithy");
+        AT(M1_UNSOLID, "FlUnSolid");
+        AT(M1_THICK_HIDE, "FlThickHide");
+        AT(M1_OVIPAROUS, "FlOviparous");
+        AT(M1_REGEN, "FlRegen");
+        AT(M1_SEE_INVIS, "FlSeeInvis");
+        AT(M1_TPORT, "FlTeleport");
+        AT(M1_TPORT_CNTRL, "FlTeleportControl");
+        AT(M1_ACID, "FlAcid");
+        AT(M1_POIS, "FlPoisonous");
+        AT(M1_CARNIVORE, "FlCarnivore");
+        AT(M1_HERBIVORE, "FlHerbivore");
+        AT(M1_METALLIVORE, "FlMetallivore");
+#undef AT
+#define AT(a, b) if (pm->mflags2 & a) fprintf(f, ", %s", b);
+#ifdef M2_NOPOLY
+        AT(M2_NOPOLY, "FlNoPoly");
+#endif
+        AT(M2_UNDEAD, "FlUndead");
+        AT(M2_WERE, "FlWere");
+        AT(M2_HUMAN, "FlHuman");
+        AT(M2_ELF, "FlElf");
+        AT(M2_DWARF, "FlDwarf");
+        AT(M2_GNOME, "FlGnome");
+        AT(M2_ORC, "FlOrc");
+        AT(M2_DEMON, "FlDemon");
+        AT(M2_MERC, "FlMerc");
+        AT(M2_LORD, "FlLord");
+        AT(M2_PRINCE, "FlPrince");
+        AT(M2_MINION, "FlMinion");
+        AT(M2_GIANT, "FlGiant");
+        AT(M2_MALE, "FlMale");
+        AT(M2_FEMALE, "FlFemale");
+        AT(M2_NEUTER, "FlNeuter");
+        AT(M2_PNAME, "FlProperName");
+        AT(M2_HOSTILE, "FlHostile");
+        AT(M2_PEACEFUL, "FlPeaceful");
+        AT(M2_DOMESTIC, "FlDomestic");
+        AT(M2_WANDER, "FlWander");
+        AT(M2_STALK, "FlStalk");
+        AT(M2_NASTY, "FlNasty");
+        AT(M2_STRONG, "FlStrong");
+        AT(M2_ROCKTHROW, "FlRockThrow");
+        AT(M2_GREEDY, "FlGreedy");
+        AT(M2_JEWELS, "FlJewels");
+        AT(M2_COLLECT, "FlCollect");
+        AT(M2_MAGIC, "FlMagicCollect");
+#undef AT
+#define AT(a, b) if (pm->mflags3 & a) fprintf(f, ", %s", b);
+        AT(M3_WANTSAMUL, "FlWantsAmulet");
+        AT(M3_WANTSBELL, "FlWantsBell");
+        AT(M3_WANTSBOOK, "FlWantsBook");
+        AT(M3_WANTSCAND, "FlWantsCand");
+        AT(M3_WANTSARTI, "FlWantsArti");
+        AT(M3_WANTSALL, "FlWantsAll");
+        AT(M3_WAITFORU, "FlWaitsForYou");
+        AT(M3_CLOSE, "FlClose");
+        AT(M3_COVETOUS, "FlCovetous");
+        if (hates_silver(pm)) fprintf(f, ", FlHatesSilver");
+        if (passes_bars(pm)) fprintf(f, ", FlPassesBars");
+        if (vegan(pm)) fprintf(f, ", FlVegan");
+        else if (vegetarian(pm)) fprintf(f, ", FlVegetarian");
+
+#undef AT
+        fprintf(f, "]), ");
+        fprintf(f, "moColor = ");
+        switch(pm->mcolor)
+        {
+            case CLR_BLACK: fprintf(f, "Black"); break;
+            case CLR_RED: fprintf(f, "Red"); break;
+            case CLR_GREEN: fprintf(f, "Green"); break;
+            case CLR_BROWN: fprintf(f, "Brown"); break;
+            case CLR_BLUE: fprintf(f, "Blue"); break;
+            case CLR_MAGENTA: fprintf(f, "Magenta"); break;
+            case CLR_CYAN: fprintf(f, "Cyan"); break;
+            case CLR_GRAY: fprintf(f, "Gray"); break;
+            case CLR_ORANGE: fprintf(f, "Orange"); break;
+            case CLR_BRIGHT_GREEN: fprintf(f, "BrightGreen"); break;
+            case CLR_BRIGHT_BLUE: fprintf(f, "BrightBlue"); break;
+            case CLR_BRIGHT_CYAN: fprintf(f, "BrightCyan"); break;
+            case CLR_BRIGHT_MAGENTA: fprintf(f, "BrightMagenta"); break;
+            case CLR_YELLOW: fprintf(f, "Yellow"); break;
+            case CLR_WHITE: fprintf(f, "White"); break;
+            default: fprintf(stderr, "I don't know what color %d is.\n",
+                             pm->mcolor);
+                     abort();
+        }
+        fprintf(f, " }\n");
+    }
+    fprintf(f, "  | otherwise = Nothing\n\n");
+    fprintf(f, "allMonsterNames :: [T.Text]\n");
+    fprintf(f, "allMonsterNames = [");
+    for (i1 = 0; mons[i1].mname[0]; ++i1)
+    {
+        if (i1 > 0)
+            fprintf(f, ", ");
+        fprintf(f, "\"%s\"", mons[i1].mname);
+    }
+    fprintf(f, "]\n\n");
+
+}
+
+static void extract_itemdata_to_haskell(FILE* f)
+{
+}
+
+
 /*unixmain.c*/
